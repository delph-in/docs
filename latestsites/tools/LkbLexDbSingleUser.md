{% raw %}# SINGLE USER LexDB

- First, set up psql. A simple set up is discussed in
[LexDbSimplePsql](https://delph-in.github.io/docs/tools/LexDbSimplePsql) (the details which will work for
single-user and multi-user mode are in
[LexDbPsqlInitialize](https://delph-in.github.io/docs/tools/LexDbPsqlInitialize))
- Then, initialize a database, populate it with the lexicon entries
from a lexicon.tdl file and tell the LKB to use this when you load a
grammar. Step-by-step instructions follow. These instructions
presuppose that you already have suitable mappings from the paths in
the typed feature structures to database fields in a .dfn file. The
easiest approach is to use an existing .dfn file as a model. More
details are given in [LexDbInitialize](https://delph-in.github.io/docs/tools/LexDbInitialize).

The instructions as given below are suitable if you want to use the ERG
with a Lex DB in single user mode.

## SETUP INSTRUCTIONS for SINGLE USER LexDB

\[a version of these instructions may be found in
lkb/lexdb/README.single-user\]

    $ export MyLexDB=erg
    $ createdb $MyLexDB

\[The database is initialized using the SQL script file 'su-init.sql'
which may be edited first to specify the Lex DB fields you want. See
[LexDbFieldMappings](https://delph-in.github.io/docs/tools/LexDbFieldMappings) for further information. \]

    $ psql $MyLexDB
    => \i su-init.sql

\[now load the field mappings...\]

    => \copy dfn from lexdb.dfn
    => \q

\[NOW load your grammar, as normal, in the LKB, then open a connection
to the currently empty LexDB...\]

    LKB(): (initialize-lexdb :type :single-user :dbname "erg")

\[and export your lexicon to dump files for the database. The files will
go into your LKB tmp directory. \]

    LKB(): (export-lexicon)

\[import the dump file into the database...\] \[NOTE: encoding of
lexicon/dump files must be UTF-8\]

    $ psql $MyLexDB
    => \copy lex from /home/bmw20/tmp/LinGO.rev

\[Now set the parameters in the LKB appropriately, via the menu\]

    LKB->Options->Set Options->*LEXDB-PARAMS* = ((:dbname "erg") (:type :single-user))

\[Edit the LKB script file to specify that the database should be used,
if necessary. The ERG script is already set up to do this, but see
[LexDbInitialize](https://delph-in.github.io/docs/tools/LexDbInitialize) if you are working with a grammar
which has not previously been used with the Lex DB. \]

\[NOW reload grammar in LKB, and you should see a messages similar to
the following: \]

    ...
    (LexDB) connected to LexDB erg2@localhost:5432 as database user bmw20
    (LexDB) total 'lex' entries available: 23055
    ...

\[now we initialize the table of orthography keys, which allows the Lex
DB to be used for parsing ...\]

    LKB(): (new-lex-key-table *lexicon*)

\[and the database SEMI, for indices for generation (although it will
still be necessary to index the lexicon before it is possible to
generate) ...\]

    LKB(): (new-semi *lexicon*)

THAT'S IT

If anything goes wrong, and you need to start over, you can clear the
database by:

    $ dropdb $MyLexDB

Description:

- \- lexicon entries should be made available in 'lex' (which can be a
table or a view) - the mapping from database fields into AVM
path-values in specified in 'dfn' - a table 'lex\_key' is generated
by '(new-lex-key-table \*lexicon\*)' and is used for lexicon
lookup - a number of tables (and a view) 'semi\_\*' are generated by
'(new-semi \*lexicon\*)' and store the database object SEMI - you
are responsible for ensuring that there exists an appropriate index
on the 'name' field of 'lex' (or things will run slow...) - you are
free to define 'lex' as a view (eg. you could store a large number
of lexicon entries in another table 'all\_entries', create a table
'active'to specify which entry 'name's you want in view, then define
'lex' as:
  - CREATE VIEW lex AS active JOIN all\_entries USING name;

Last update: 2009-04-10 by AnnCopestake [[edit](https://github.com/delph-in/docs/wiki/LkbLexDbSingleUser/_edit)]{% endraw %}